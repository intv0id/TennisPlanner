@page "/search"
@inject ITennisClient TennisClient
@inject IGeoClient GeoClient
@inject ITransportClient TransportClient
@inject ILoggerService LoggerService
@inject INotificationService NotificationService
@using Blazored.Typeahead
@using TennisPlanner.Core.Contracts
@using TennisPlanner.Core.Clients
@using TennisPlanner.Core.Extensions
@using TennisPlanner.Server.Models
@using TennisPlanner.Server.Services
@using TennisPlanner.Shared.Services.Logging

<h1>Recherche de créneaux</h1>

<EditForm Model="@searchModel" OnValidSubmit="@HandleSearch">
    <div class="container">
    <div class="row">
    <div class="col col-sm-4">
        <label for="selected-date-form">Date</label>
        <InputDate @bind-Value="searchModel.SelectedDate" class="input-group date" id="selected-date-form" />
    </div>

    <div class="col col-sm-7">
        <label for="address-player-1">Départ joueur 1</label>
        <BlazoredTypeahead 
            SearchMethod="GeoClient.GetAddressAutocompleteAsync"
            @bind-Value="searchModel.SelectedAddressPlayer1"
            id="address-player-1">
            <SelectedTemplate Context="templateContext">
                @if(templateContext != null)
                {
                    <span>
                        @templateContext.Properties.Name,
                        @templateContext.Properties.PostCode, 
                        @templateContext.Properties.City
                    </span>
                }
            </SelectedTemplate>
            <ResultTemplate Context="templateContext">
                @if(templateContext != null)
                {
                    <span>
                        @templateContext.Properties.Name, 
                        @templateContext.Properties.PostCode, 
                        @templateContext.Properties.City
                    </span>
                }
            </ResultTemplate>
        </BlazoredTypeahead>

        <br/>
        
        <label for="address-player-2">Départ joueur 2</label>
        <BlazoredTypeahead 
            SearchMethod="GeoClient.GetAddressAutocompleteAsync" 
            @bind-Value="searchModel.SelectedAddressPlayer2"
            id="address-player-1">
            <SelectedTemplate Context="templateContext">
                @if(templateContext != null)
                {
                    <span>
                        @templateContext.Properties.Name,
                        @templateContext.Properties.PostCode, 
                        @templateContext.Properties.City
                    </span>
                }
            </SelectedTemplate>
            <ResultTemplate Context="templateContext">
                @if(templateContext != null)
                {
                    <span>
                        @templateContext.Properties.Name, 
                        @templateContext.Properties.PostCode, 
                        @templateContext.Properties.City
                    </span>
                }
            </ResultTemplate>
        </BlazoredTypeahead>
        @if(searchModel.SelectedAddressPlayer2 != null)
        {
            <span class="basic-addon1"><i class="bi bi-check"/></span>
        }

    </div>
    </div>
    
    <br/>

    <button class="btn btn-primary" type="submit" disabled="@(!ValidateFields())">Chercher</button>

    </div>
</EditForm>

@if (Availabilities != null)
{
    <table class="table">
        <thead>
            <tr>
                <th>Heure</th>
                <th>Lieu</th>
                <th>Court</th>
                <th>Sol</th>
                <th>Couvert</th>
                <th>Eclairé</th>
                @if(TransportSearchEnabled())
                {
                    <th>Transport joueur 1<br/>(dont marche)</th>
                    <th>Transport joueur 2<br/>(dont marche)</th>
                }

            </tr>
        </thead>
        <tbody>
            @foreach (var courtAvailable in Availabilities)
            {
                <tr>
                    <td>@courtAvailable.TimeRange.StartHour h - @courtAvailable.TimeRange.EndHour h</td>
                    <td>@courtAvailable.CourtInfo.Facility.Name</td>
                    <td>@courtAvailable.CourtInfo.Title</td>
                    <td>@courtAvailable.CourtInfo.Ground</td>
                    <td>@courtAvailable.CourtInfo.Roof</td>
                    <td>@courtAvailable.CourtInfo.Light</td>
                    @if (TransportSearchEnabled())
                    {
                        <td>
                            @if (courtAvailable.TravelInfo.JourneyDurationFromAdress1 == null)
                            {
                                <span>N/A</span>
                            }
                            else
                            {
                                <span>
                                    @(courtAvailable.TravelInfo.JourneyDurationFromAdress1?.TotalDurationInSeconds / 60)'
                                    (@(courtAvailable.TravelInfo.JourneyDurationFromAdress1?.WalkingDurationInSeconds / 60)')
                                </span>
                            }
                        </td>
                        <td>
                            @if (courtAvailable.TravelInfo.JourneyDurationFromAdress2 == null)
                            {
                                <span>N/A</span>
                            }
                            else
                            {
                                <span>
                                    @(courtAvailable.TravelInfo.JourneyDurationFromAdress2?.TotalDurationInSeconds / 60)'
                                    (@(courtAvailable.TravelInfo.JourneyDurationFromAdress2?.WalkingDurationInSeconds / 60)')
                                </span>
                            }
                        </td>
                    }
                </tr>
            }
        </tbody>
    </table>
}

@code {
    SearchModel searchModel = new();
    bool IsSearchEnabled;
    IEnumerable<TimeSlot>? Availabilities;

    protected override async Task OnInitializedAsync()
    {
        await Task.Yield();
        searchModel.SelectedDate = DateTime.Today;
    }

    private async Task HandleSearch()
    {
        if (searchModel.SelectedDate == null)
        {
            LoggerService.Log(
                logLevel: LogLevel.Error,
                operationName: $"{nameof(Search)}.{nameof(this.HandleSearch)}",
                message: $"{nameof(searchModel.SelectedDate)} is null.");

            NotificationService.Display(
                level: LogLevel.Error,
                message: "A error occured.");

            return;
        }

        Availabilities = await fetchAvailabilitiesAsync(
            date: searchModel.SelectedDate.Value,
            transportSearch: TransportSearchEnabled());
    }

    private async Task<IEnumerable<TimeSlot>> fetchAvailabilitiesAsync(DateTime date, bool transportSearch)
    {
        var courts = await TennisClient.GetTennisCourtsListAsync();
        var availabilities = await Task.WhenAll(
            courts.Select(async court => await TennisClient.GetTimeSlotListAsync(court, date)));
        var tennisSlots = availabilities.SelectMany(x => x);

        tennisSlots = filterSlots(tennisSlots);

        if (transportSearch)
        {
            tennisSlots = await Task.WhenAll(tennisSlots.Select(GetTransportationTimesAsync));
        }

        tennisSlots = orderSlots(tennisSlots);

        return tennisSlots;
    }

    private async Task<TimeSlot> GetTransportationTimesAsync(TimeSlot timeSlot)
    {
        if (searchModel.SelectedAddressPlayer1 == null || searchModel.SelectedAddressPlayer2 == null)
        {
            throw new ArgumentException("Selected address is null.");
        }

        if (searchModel.SelectedDate == null)
        {
            throw new ArgumentException("Selected date is null.");
        }

        var transportationArrivalDate = new DateTime(
            year: searchModel.SelectedDate.Value.Year,
            month: searchModel.SelectedDate.Value.Month,
            day: searchModel.SelectedDate.Value.Day,
            hour: timeSlot.TimeRange.StartHour,
            minute: 0,
            second: 0);

        var transportationTime1 = await TransportClient.GetTransportationTimeInMinutesAsync(
            arrivalTime: transportationArrivalDate,
            fromGeoCoordinates: searchModel.SelectedAddressPlayer1.Geometry.Coordinates.ToGeoCoordinates(),
            toGeoCoordinates: timeSlot.CourtInfo.Facility.Coordinates);
        var transportationTime2 = await TransportClient.GetTransportationTimeInMinutesAsync(
            arrivalTime: transportationArrivalDate,
            fromGeoCoordinates: searchModel.SelectedAddressPlayer2.Geometry.Coordinates.ToGeoCoordinates(),
            toGeoCoordinates: timeSlot.CourtInfo.Facility.Coordinates);

        timeSlot.TravelInfo.JourneyDurationFromAdress1 = transportationTime1;
        timeSlot.TravelInfo.JourneyDurationFromAdress2 = transportationTime2;

        return timeSlot;
    }

    private IEnumerable<TimeSlot> filterSlots(IEnumerable<TimeSlot> slots)
    {
        // TODO filter slots by hour
        return slots;
    }

    private IEnumerable<TimeSlot> orderSlots(IEnumerable<TimeSlot> slots)
    {
        var orderedByTimeSlots = slots.OrderBy(s => s.TimeRange.StartHour);

        if (TransportSearchEnabled())
        {
            return orderedByTimeSlots.ThenBy(s => 
                travelTimeMetric(s.TravelInfo.JourneyDurationFromAdress1?.TotalDurationInSeconds, s.TravelInfo.JourneyDurationFromAdress1?.TotalDurationInSeconds));
        }

        return orderedByTimeSlots;
    }

    private bool ValidateFields()
    {
        var selectedDate = searchModel.SelectedDate;
        if (selectedDate == null || selectedDate < DateTime.Today || selectedDate > DateTime.Today.AddDays(7))
        {
            return false;
        }
        return true;
    }

    private bool TransportSearchEnabled()
    {
        return searchModel?.SelectedAddressPlayer1 != null
            && searchModel?.SelectedAddressPlayer2 != null;
    }

    private double travelTimeMetric(int? duration1, int? duration2)
    {
        if (duration1 == null || duration2 == null)
        {
            return double.PositiveInfinity;
        }

        return Math.Pow((int)duration1, 2) + Math.Pow((int)duration2, 2);
    }

    private async Task OnPartialAddress1Changed(string value)
    {
        searchModel.AddressSuggestionsPlayer1 = await GeoClient.GetAddressAutocompleteAsync(value);
    }

    private async Task OnPartialAddress2Changed(string value)
    {
        searchModel.AddressSuggestionsPlayer2 = await GeoClient.GetAddressAutocompleteAsync(value);
    }
}
